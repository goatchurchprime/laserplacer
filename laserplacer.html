<!DOCTYPE html>
<html>
<head>
<script src="jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="raphael.js"></script>    
<script type="text/javascript" src="raphpolygonsorting.js"></script>    
<script type="text/javascript" src="raphimporting.js"></script>    
<script type="text/javascript" src="svgizingtext.js"></script>    
<meta charset="utf-8">
<title>Experimental SVG lattice hinge generator V4</title>
<script>


function exportSVG()
{
    var xs = new XMLSerializer();
    var data = document.getElementById("svg1");
    var a = document.createElement('a');
    var blob = new Blob([xs.serializeToString(data)], {'type':"image/svg+xml"});
    a.href = window.URL.createObjectURL(blob);
    a.download = "test.svg";
    a.click();
}


var bcancelExIm = false; 
var cosang = 5; 
var cosangdot = Math.cos(cosang*Math.PI/180); 
var TXlinestylespnum = { "subsetarea":0, "Wall":1, "EstW":1, "Detl":2, "symbDetl":2, "CeilB":2, "Pitc":2, "Cent":3, "symbFill":4 }; 
//alert("hi"); 
function exportPLT()
{
//console.log("exportingJSON instead"); 
//return exportJSON(); 

    var svgprocess = SVGprocesses[fadividlast]; 
    var rlistb = svgprocess.rlistb; 
    var mmpixwidth = parseFloat($("#mmpixwidth").val()); 
    
    var lplt = [ "IN;\n", "WU0;\n" ]; 
    var samplerateunit = 0.9; 
    var fac = 40/mmpixwidth; // PLT file operates at 40units per pixel
    var ytop = 10000; 
    var i = 0; 
    bcancelExIm = false; 
    $("#readingcancel").text("exportPLT"); 
    function exportPLTpathR() {
        var path = rlistb[i].path; 
        var d = path.attr("path"); 
        var dtrans = Raphael.mapPath(d, path.matrix); 
        var fpts = PolySorting.flattenpath(dtrans, cosangdot, 0.0) 
        
        // uncomment to plot the flattenpath for debug viewing
        //var Lfpts = [ ]; for (var Di = 0; Di < fpts.length; Di++); Lfpts.push(fpts[Di][0]+","+fpts[Di][1]); 
        //paper1.path("M"+Lfpts.join("L")).attr("stroke", "red");  
        var spnum = rlistb[i].spnum, spnumobj; 
        if (svgprocess.btunnelxtype) {
            spnumobj = svgprocess.spnumlist[spnum]; 
            spnum = TXlinestylespnum[spnumobj.linestyle]; 
        }
        if (spnum !== undefined) {
            lplt.push("SP"+spnum+";\n"); 
            lplt.push("LT;\n"); 
            for (var j = 0; j < fpts.length; j++) {
                lplt.push((j == 0 ? "PU" : "PD")+(fpts[j][0]*fac).toFixed(3)+" "+(ytop-fpts[j][1]*fac).toFixed(3)+"\n"); 
            }
        } else if (spnumobj) {
            console.log(TXlinestylespnum[spnumobj.linestyle]); 
        }
        if (bcancelExIm) {
            return; 
        } else if (++i < rlistb.length) {
            setTimeout(exportPLTpathR, 1); 
        } else {
            lplt.push("SP0;\n"); 
            var a = document.createElement('a');
            var blob = new Blob(lplt, {'type':"text/plain"});
            a.href = window.URL.createObjectURL(blob);
            a.download = "test.plt";
            a.click();
        }
        $("#readingcancel").text(i+"/"+rlist.length); 
    };
    exportPLTpathR(); 
}

// quick hack to see if we can load into polar graph system
function exportJSON()
{
    var svgprocess = SVGprocesses[fadividlast]; 
    var rlistb = svgprocess.rlistb; 
    var mmpixwidth = parseFloat($("#mmpixwidth").val()); 
    
    var lplt = [ " " ]; 
    var samplerateunit = 0.9; 
    var fac = 1/mmpixwidth; // PLT file operates at 40units per pixel
    var ytop = 0; 
    var i = 0; 
    bcancelExIm = false; 
    $("#readingcancel").text("exportPLT"); 
    function exportJSONpathR() {
        var path = rlistb[i].path; 
        var d = path.attr("path"); 
        var dtrans = Raphael.mapPath(d, path.matrix); 
        var fpts = PolySorting.flattenpath(dtrans, cosangdot, 0.0) 
        
        // uncomment to plot the flattenpath for debug viewing
        //var Lfpts = [ ]; for (var Di = 0; Di < fpts.length; Di++); Lfpts.push(fpts[Di][0]+","+fpts[Di][1]); 
        //paper1.path("M"+Lfpts.join("L")).attr("stroke", "red");  
        var spnum = rlistb[i].spnum, spnumobj; 
        if (svgprocess.btunnelxtype) {
            spnumobj = svgprocess.spnumlist[spnum]; 
            spnum = TXlinestylespnum[spnumobj.linestyle]; 
        }
        if (spnum !== undefined) {
            for (var j = 0; j < fpts.length; j++) {
                lplt.push((j == 0 ? "M" : "L")+(200+fpts[j][0]*fac).toFixed(3)+" "+(fpts[j][1]*fac-ytop).toFixed(3)); 
            }
        } else if (spnumobj) {
            console.log(TXlinestylespnum[spnumobj.linestyle]); 
        }
        if (bcancelExIm) {
            return; 
        } else if (++i < rlistb.length) {
            setTimeout(exportJSONpathR, 1); 
        } else {
            lplt.push(""); 
            var a = document.createElement('a');
            var blob = new Blob(lplt, {'type':"text/plain"});
            a.href = window.URL.createObjectURL(blob);
            a.download = "test.plt";
            a.click();
        }
        $("#readingcancel").text(i+"/"+rlist.length); 
    };
    exportJSONpathR(); 
}


function rescalefile(fscale)
{
    var svgprocess = SVGprocesses[fadividlast]; 
    var rlistb = svgprocess.rlistb; 
    for (var i = 0; i < rlistb.length; i++) {
        rlistb[i].path.attr("path", Raphael.mapPath(rlistb[i].path.attr("path"), Raphael.matrix(fscale, 0, 0, fscale, 0, 0))); 
        //rlistb[i].path.scale(fscale, fscale, 0, 0); 
    }
    svgprocess.Lgrouppaths[0][0].attr("path", Raphael.mapPath(svgprocess.Lgrouppaths[0][0].attr("path"), Raphael.matrix(fscale, 0, 0, fscale, 0, 0))); 
}

// this works from a position of no processing or re-ordering, like was done to the cutting paths for the laser
// (we need to lightly reorder it)
function sendgcode()
{
    var svgprocess = SVGprocesses[fadividlast]; 
    var rlistb = svgprocess.rlistb; 
    var mmpixwidth = parseFloat($("#mmpixwidth").val()); 
    
    var samplerateunit = 0.9; 
    var fac = 1.0/mmpixwidth; 
    var xtopmm = machinekitstats.xlo; 
    var ytopmm = machinekitstats.yhi; 
    var thinningtolerancemm = 1.1; 
    var breorder = true; 
    
    var rlfptseqs = [ ]; 
    var i = 0; 
    bcancelExIm = false; 
    var lgcode = undefined; 
    var ptlink = [ -xtopmm/fac, ytopmm/fac ]; // page origin
    var finalx = (machinekitstats.xlo+machinekitstats.xhi)/2; 
    
    $("#readingcancel").text("processinggcode"); 
    function exportGCODEpathR() {
        if (bcancelExIm)
            return; 
            
        if (lgcode == undefined) {
            var path = rlistb[rlfptseqs.length].path; 
            var d = path.attr("path"); 
            var dtrans = Raphael.mapPath(d, path.matrix); 
            var fpts = PolySorting.flattenpath(dtrans, cosangdot, thinningtolerancemm*fac) 
            rlfptseqs.push(fpts); 
            
            // next phase
            if (rlfptseqs.length == rlistb.length) {
                $("#readingcancel").text("ordersendinggcode"); 
                lgcode = [ "G64P0.2", "G0Z5F20000\n" ]; 
            }
            setTimeout(exportGCODEpathR, 1); 
            return; 
        }
        
        var fpts; 
        var ddistlink = 100 + thinningtolerancemm*fac*2; 
        if (breorder) {
            var ilink = -1; 
            var ibreverse; 
            for (var i = 0; i < rlfptseqs.length; i++) {
                var lfpts = rlfptseqs[i]; 
                var ddistfront = Math.abs(lfpts[0][0] - ptlink[0]) + Math.abs(lfpts[0][1] - ptlink[1]); 
                var ddistback = Math.abs(lfpts[lfpts.length-1][0] - ptlink[0]) + Math.abs(lfpts[lfpts.length-1][1] - ptlink[1]); 
                if ((ilink == -1) || (ddistfront < ddistlink)) {
                    ddistlink = ddistfront; 
                    ilink = i; 
                    ibreverse = false; 
                }
                if (ddistback < ddistlink) {
                    ddistlink = ddistback; 
                    ilink = i; 
                    ibreverse = true; 
                }
            }
            var fpts = rlfptseqs[ilink]; 
            if (ilink != rlfptseqs.length - 1) {
                rlfptseqs[ilink] = rlfptseqs.pop(); 
            } else {
                rlfptseqs.pop(); 
            }
            if (ibreverse)
                fpts.reverse(); 
            ptlink = fpts[fpts.length - 1]; 
        } else {
            fpts = rlfptseqs.pop(); 
        }

        // uncomment to plot the flattenpath for debug viewing
        //var Lfpts = [ ]; for (var Di = 0; Di < fpts.length; Di++); Lfpts.push(fpts[Di][0]+","+fpts[Di][1]); 
        //paper1.path("M"+Lfpts.join("L")).attr("stroke", "red");  
        
        var spnum = 1; //rlistb[i].spnum;   // what's this comma clause doing???!
        if (spnum !== undefined) {
            for (var j = 0; j < fpts.length; j++) {
                var bretract = ((j == 0) && ((lgcode.length <= 4) || (ddistlink >= thinningtolerancemm*fac*2))); 
                lgcode.push((bretract ? "G0Z5\nX" : "X") + (xtopmm+fpts[j][0]*fac).toFixed(3) + "Y" + (ytopmm-fpts[j][1]*fac).toFixed(3) + "\n"); 
                finalx = xtopmm+fpts[j][0]*fac; 
                if (bretract)
                    lgcode.push("G1Z0\n"); 
            }
        } else if (spnumobj) {
            console.log(TXlinestylespnum[spnumobj.linestyle]); 
        }
        
        if (rlfptseqs.length != 0) {
            setTimeout(exportGCODEpathR, 1); 
        } else {
            var movex = (finalx > 0 ? finalx-100 : finalx+100);
            lgcode.push("G0Z5\nX"+movex.toFixed(3)+"M2\n"); 
			var a = document.createElement('a');
			var blob = new Blob(lgcode, {'type':"text/plain"});
			a.href = window.URL.createObjectURL(blob);
			a.download = "test.ngc";
			a.click();
        }
        $("#readingcancel").text((rlist.length-rlfptseqs.length)+"/"+rlist.length); 
    };
    
    exportGCODEpathR(); 
}


var machinekitstats = undefined; 
var toscasizerect = undefined; 
function receivemachinekitstats(lmachinekitstats)
{
    machinekitstats = lmachinekitstats; 
    console.log(machinekitstats); 
    var mkstatus = "fetched"; 
    if (machinekitstats["response"] == "bad")
        mkstatus = "not working"
    else if (machinekitstats["estop"] != 0)
        mkstatus = "estop";
    else if (!machinekitstats["enabled"])
        mkstatus = "disabled";
    else if ((machinekitstats["homed"][0] == 0) || (machinekitstats["homed"][1] == 0) || (machinekitstats["homed"][2] == 0))
        mkstatus = "not homed";
    else if (machinekitstats["interp_state"] != machinekitstats.INTERP_IDLE)
        mkstatus = "not idle";
    else
        mkstatus = "mkready"; 
    $("#machinekitstatus").text(mkstatus); 
    if (machinekitstats.xlo !== undefined) {
        if (toscasizerect !== undefined)
            toscasizerect.remove(); 
        var mmpixwidth = parseFloat($("#mmpixwidth").val()); 
        var mmwidth = machinekitstats.xhi - machinekitstats.xlo; 
        var mmheight = machinekitstats.yhi - machinekitstats.ylo; 
        toscasizerect = paper1.rect(15, 15, mmwidth*mmpixwidth, mmheight*mmpixwidth).attr({stroke:"grey", fill:"lightGrey"}).toBack(); 
    }
}

function requestmachinekitstats() 
{
    var stdindata = ""; 
    var rdata = stdindata; 
    $("#machinekitstatus").text("requesting..."); 
	console.log("making machinekitstats numbers up"); 
	receivemachinekitstats({"xlo":-620, "xhi":520, "ylo":-190, "yhi":600, "estop":0, "enabled":1, "homed":[1, 1, 1], "interp_state":1, INTERP_IDLE:1}); 
}


function TestCollision(dx, dy) 
{
    for (var i = 0; i < opts.length; i++) {
        var x = opts[i][0] + dx; 
        var y = opts[i][1] + dy; 
        if (y >= paper1.height*paper1scale)
            return false; 
        for (var j = 0; j < rlist.length; j++) {
            if (rlist[j] == pathselected)
                continue; 
            if (rlist[j].isPointInside(x, y))
                return false; 
        }
    }
    return true; 
}

var paper1 = null; 
var paper1scale = 1; 
var paper1x0 = 0; 
var paper1y0 = 0; 
var filenamelist = { }; 
var rlist = [ ]; 
var SVGprocesses = { }; // indexed by fadivid (type SVGfileprocess, which it gets confused with)
var Dsvgprocess = undefined; // lastone
var fadividlast = undefined; 
var pathselected = null; 
var opts; 
var collidestepout = 10, collidestepover = 10; 
var ylo, yhi; 
var perprods; 
var Lgrouppath = []; 
function CollideBinary() 
{
    // paper1.getElementsByPoint(x, y); 
    var ymid = (ylo + yhi)/2; 
    if (TestCollision(0, ymid)) {
        ylo = ymid; 

        var basematrix = pathselected.matrix.toTransformString(); 
        var tstr = "t0,"+ylo+basematrix; 
        for (var k = 0; k < Lgrouppath.length; k++) {
            Lgrouppath[k].transform(tstr); 
        }; 

    } else {
        yhi = ymid; 
    }
    if (yhi - ylo <= collidestepout + 1) {
        perprods.remove(); 
    } else {
        setTimeout(CollideBinary, 5); 
    }
}

/* refer to: 
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
*/

function MoveCollide()
{
    path = pathselected; 
    var dtrans = Raphael.mapPath(path.attr("path"), path.matrix); 
    var pl = Raphael.getTotalLength(dtrans); 
    console.log(pl); 
    var ds = [ ]; 
    opts = [ ]; 
    for (var i = 0; i < pl; i += collidestepover) {
        var pal = Raphael.getPointAtLength(dtrans, i); 
        var angnorm = Raphael.rad(pal.alpha+90); 
        var sa = Math.sin(angnorm); 
        var ca = Math.cos(angnorm); 
        var d = collidestepout; 
        if (Raphael.isPointInsidePath(dtrans, pal.x+ca*d, pal.y+sa*d)) { d = -d }; 
        ds.push("M", pal.x, ",", pal.y, "l", ca*d, ",", sa*d); 
        opts.push([pal.x+ca*d, pal.y+sa*d]); 
    }
    
    perprods = paper1.path(ds.join("")); 
    ylo = 0; 
    yhi = 400; 
    
    Lgrouppath = null; 
    var Lgrouppaths = SVGprocesses[fadividlast].Lgrouppaths; 
    for (var k = 0; k < Lgrouppaths.length; k++) {
        if (Lgrouppaths[k][0] == pathselected)
            Lgrouppath = Lgrouppaths[k]; 
    }
    setTimeout(CollideBinary, 5); 
}

Dtranslats = null; 
Dxjson = null; 
function Nest1() 
{
    var polymap = { }; 
    var board = [ ]; 
    var sequence = [ ]; 
    var Ipolymap = { }; 
    //for (var i = 0; i < SVGprocesses.length; i++) {
    Object.keys(a).forEach(function(key, i) {  // untested after the above change from list to object
        var svgp = SVGprocesses[key]; 
        for (var j = 0; j < svgp.Lgrouppaths.length; j++) {
            var pth = svgp.Lgrouppaths[j][0].attr("path"); 
            var pgid = svgp.pathgroupings[j][0]; 
            polymap[pgid] = pth; 
            Ipolymap[pgid] = [key, j]; 
            
            if ((i == 0) && (j == 0)) {
                board.push(pgid); 
            } else {
                sequence.push(pgid); 
            }
        }
    }); 
}

var Df; 

var filecountid = 0; 
function importSVGfiles(files)
{
    $.each(files, function(i, f) { 
        var beps = f.type.match('image/x-eps'); 
        var bsvg = f.type.match('image/svg\\+xml'); 
        var bsvgizedtext = f.type.match('svgizedtext'); 
        var bdxf = f.type.match('image/vnd\\.dxf'); 
        
        if (!beps && !bsvg && !bdxf && !bsvgizedtext) {
            alert(f.name+" not SVG, EPS or DXF file: "+f.type); 
            return;
        }
        
        
        if (Drect1 != null) {
            Drect1.remove(); 
            Drect1 = null; 
        }
        var fadivid = 'fa'+filecountid; 
        filecountid++; 
        filenamelist[fadivid] = f.name; 
        $("div#filearea").append('<div id="'+fadivid+'"></div>'); 
        $("div#"+fadivid).append('<span class="delbutton">&times;</span>'); 
        $("div#"+fadivid).append('<b>'+f.name+'</b>: '); 
        $("div#"+fadivid).append('<span class="spnumcols"></span>'); 
        $("div#"+fadivid).append('<span class="fprocessstatus">VV</span>'); 
        $("div#"+fadivid).append('<span class="groupprocess">GGoup</span>'); 
        
        var svgprocess = new SVGfileprocess(f.name, fadivid); 
        
        $("div#"+fadivid+" .fprocessstatus").click(function() { svgprocess.bcancelIm = true; }); 
        $("div#"+fadivid+" .groupprocess").click(function() { 
            if ($(this).hasClass("selected")) {
                $(this).removeClass("selected"); 
            } else {
                $(this).addClass("selected"); 
                if (svgprocess.state.match(/doneimportsvgr|doneimportsvgrareas/))
                    svgprocess.groupimportedSVGfordrag((svgprocess.btunnelxtype ? "grouptunnelx" : "groupcontainment")); 
                else if (svgprocess.state.match(/processimportsvgrareas/))
                    svgprocess.LoadTunnelxDrawingDetails(); 
                else 
                    svgprocess.groupimportedSVGfordrag((svgprocess.btunnelxtype ? "grouptunnelx" : "groupcontainment")); // reprocess again
            }
        }); 
        $("div#"+fadivid+" .delbutton").click(function() { 
            var lfadivid = $(this).parent("div").attr("id"); 
            SVGprocesses[lfadivid].removeall(); 
            delete SVGprocesses[lfadivid]; 
            $("div#"+fadivid).remove(); 
        }); 
        
        SVGprocesses[fadivid] = svgprocess; 
        fadividlast = fadivid; 
        Dsvgprocess = svgprocess; 
Df = f;         
        var reader = new FileReader(); 
        if (bsvgizedtext) {
            svgprocess.InitiateLoadingProcess(f.svgtext); 
        } else if (bsvg) {
            reader.onload = (function(e) { svgprocess.InitiateLoadingProcess(reader.result); }); 
            reader.readAsText(f); 
        } else {
			alert("not svg type"); 
        }
    }); 
}



var Deee; 

var Rmmscalebar = null; 
var Drect1;
function setup()
{
    $("#exportSVG").click(exportSVG); 
    $("#exportPLT").click(exportPLT); 
    $("#movecollide").click(MoveCollide); 
    $("#nest1").click(Nest1); 
    $("#files").change(function(e) { importSVGfiles(e.target.files); });  
    $("#mmpixwidth").change(function() { 
        if (Rmmscalebar != null) {
            Rmmscalebar.remove(); 
            Rmmscalebar = null; 
        }
        var mmpixwidth = parseFloat($("#mmpixwidth").val()); 
        var woodwidth = 100; 
        var woodheight = 100; 
        Rmmscalebar = paper1.path("M10,10h"+(woodwidth*mmpixwidth)+"v5 M10,10v"+(woodheight*mmpixwidth)+"h5").attr("stroke", "#888"); 
    }); 
    
    $("#sendgcode").click(sendgcode); 
    $("#requestmachinekitstats").click(requestmachinekitstats); 
    $("#svgizetext").click(function() { 
		importSVGfiles([{type:'svgizedtext', svgtext:svgizetext($("#texttosvgize").val())}]); 
    }); 
    
    $("#paper1").on('dragover', function(e) {
        e.stopPropagation(); e.preventDefault(); 
    }).on('dragenter', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).addClass("dropfileselected"); 
    }).on('dragleave', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).removeClass("dropfileselected"); 
    }).on('drop', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).removeClass("dropfileselected"); 
        importSVGfiles(e.originalEvent.dataTransfer.files); 
    }); 

    $("#scaledouble").click(function() { $("#scaledouble").text($("#scaledouble").text() == "*2" ? "/2" : "*2"); }); 
    $("#scale").click(function() { 
        paper1scale *= ($("#scaledouble").text() == "*2" ? 2 : 0.5); 
        paper1.setViewBox(paper1x0*paper1scale, paper1y0*paper1scale, paper1.width*paper1scale, paper1.height*paper1scale); 
        $("#scale").text(paper1scale); 
    }); 
    $("#scaledouble, #scale").mousedown(function(e) { e.preventDefault(); }); // stop selection on double-click
    $("#scale").text(paper1scale); 
    
    // setup the raphael paper and bits
    paper1 = Raphael("paper1", 1300, 800);
    paper1.setViewBox(paper1x0*paper1scale, paper1y0*paper1scale, paper1.width*paper1scale, paper1.height*paper1scale); 
    //paper1.raphael.mousedown(function(e) { console.log(e); }); 
    $(paper1.canvas).bind('mousewheel DOMMouseScroll', function(e) {
		console.log(e); 

		var ex, ey, ed; 
		if (e.handleObj && (e.handleObj.type == "DOMMouseScroll"))  {// firefox issue
			//console.log(e.originalEvent); 
			ex = e.originalEvent.clientX; 
			ey = e.originalEvent.clientY; 
			ed = (e.originalEvent.detail > 0); 
		} else {
			ex = e.clientX; 
			ey = e.clientY; 
			ed = (e.originalEvent.deltaY > 0); 
		}
        var paperelement = document.getElementById("paper1");
        var mx = ex - paperelement.offsetLeft - 2; 
        var my = ey - paperelement.offsetTop - 2; 
        //console.log(e.originalEvent.deltaY, mx, my, event); 
        var cx = (mx + paper1x0)*paper1scale; 
        var cy = (my + paper1y0)*paper1scale; 
        //paper1.rect(cx, cy, 5, 5); 
        paper1scale = (ed ? paper1scale*1.5 : paper1scale/1.5); 
        paper1x0 = cx/paper1scale - mx; 
        paper1y0 = cy/paper1scale - my; 
        paper1.setViewBox(paper1x0*paper1scale, paper1y0*paper1scale, paper1.width*paper1scale, paper1.height*paper1scale); 
        e.stopPropagation(); e.preventDefault(); 
        return false; 
    });
//    paper1.drag(
//         function(dx, dy, x, y, e) { /*var sv = (brotatemode ? "r"+dx+","+rotx+","+roty : "t"+dx+","+dy)+basematrix; console.log(sv); Drect1.transform(sv);*/ }, 
//         function(x, y, e)         { console.log("paper1", x, y); }, 
//         function(e)               { /*Drect1.attr("path", Raphael.mapPath(Drect1.attr("path"), Drect1.matrix)); Drect1.transform("t0,0")*/ }); 

    //Drect1 = paper1.path("M20,30 L100,122 L40, 100 Z").attr({fill: "orange"});
    Drect1 = paper1.text(200, 60, "Drop SVG here").attr({fill: "orange"}).transform("s3").attr("fill-opacity", 0.3); 
    
    //rect2 = paper1.path("M220,30 L300,122 L290, 100 Z").attr({fill: "blue"});
    var data = $("#paper1 svg").attr("id", "svg1"); 
    
    // scratch object
    var brotatemode = false; 
    var basematrix; 
    var rotx, roty; 
    Drect1.drag(
         function(dx, dy, x, y, e) { var sv = (brotatemode ? "r"+dx+","+rotx+","+roty : "t"+dx+","+dy)+basematrix; console.log(sv); Drect1.transform(sv); }, 
         function(x, y, e)         { brotatemode = e.ctrlKey; basematrix = Drect1.matrix.toTransformString(); var bbox = Drect1.getBBox(); rotx = (bbox.x+bbox.x2)/2; roty = (bbox.y+bbox.y2)/2; }, 
         function(e)               { /*Drect1.attr("path", Raphael.mapPath(Drect1.attr("path"), Drect1.matrix)); Drect1.transform("t0,0")*/ }); 
    Drect1.onDragOver(function(e) { console.log(e); }); 
    pathselected = Drect1; 
    
    $('#rescalefile').keydown(function(e) {
        if (e.keyCode == 13) {
            e.preventDefault();
            rescalefile(parseFloat($("#rescalefile").val())); 
        }
    });
}


$(document).ready(setup);   // function to call only *after* page has finished loading

</script>

<style>
#err { color:red }
.dropfileselected { background: #ffa }
#scale:hover, #scaledouble:hover { background:yellow; cursor:pointer }
div#filearea { z-index: 10; position: fixed; right:10px; background:white; border: thin blue solid }
div#filearea  { cursor:pointer; }

div#filearea .fprocessstatus:hover { background: red; cursor: pointer }
div#filearea .spnumcols span { border: thin black solid }
div#filearea  span.delbutton { color: yellow }
div#filearea  span.delbutton:hover { background: red; color: black }
div#filearea .spnumcols span.selected { color: white }
div#filearea .spnumcols span:hover { border-color:white }

div#filearea .groupprocess { background:#ffc }
div#filearea .groupprocess:hover { background:#ccf }
div#filearea .groupprocess.selected { background:#ee0 }
input#mmpixwidth { width:3em }
#texttosvgize { height: 1em }

</style>

</head>
<body bgcolor="#e8e8e8">
  
<div id="filearea">
    FileArea
</div>
<div>
    <input type="button" value="exportSVG" id="exportSVG"/>
    <input type="button" value="exportPLT" id="exportPLT"/>
    <input type="button" value="MOVE!" id="movecollide">
    <input type="button" value="Nest1" id="nest1">
    <span id="scale">1</span><span id="scaledouble">*2</span>
    <input type="file" id="files" name="files[]" multiple />
    <span id="pixscale">pix-scale(mm):<input type="text" id="mmpixwidth" name="mmpixwidth" value=""/></span>
    <span id="readingcancel">0/0</span>
    <span id="rescalefilesp">rescale:<input type="text" id="rescalefile" name="rescalefile" value="1.0"/></span>
    <input type="button" value="Send G-code" id="sendgcode"/>
    <input type="checkbox" id="gcodeautorun" title="autorun">
    <input type="button" value="MKstats" id="requestmachinekitstats"/>
    <span id="machinekitstatus"></span>
        
    <textarea id="texttosvgize">svgizing letters here</textarea>
    <input type="button" value="svgizetext" id="svgizetext">
</div>
<div style="border: thin black solid" id="paper1"></div>
  
<p>Code is at <a href="https://bitbucket.org/goatchurch/laserplacer">bitbucket.org/goatchurch/laserplacer</a></p>

<p>Work to do:
* batch delete on the x click
* grouping by a big rectangle outline that's draggable

*load the subsetareas separately and be able to pass over tsvg again to get the details
*remove Raphael.mapPath at end of transform case (practice on scratch object first, then do the mappath on output)
*remove jigsawareaoffset code from tunnelx java
*build symbol trimming tech of clippaths, possibly in a second pass over the tsvg object
*drop-down of the sizes of stock (ply) which gets plotted in brown as the area, and material (which generates the lookup for the feeds and speeds)
*select stock shape and type of material which is always underneath (allow for multiple sheets)
*batch up each object into json of [original svgpaths,transforms,sequences,islands,colours,scaletomm,boundingbox,filename,author], 
*be able to draw in minimal tiles off side of stock, post and recover from database file
*layouts are saved as json objects and reimported, merged, etc.
*pile objects along the right hand column in individual boxes
*file select dropdowns that refer to local banks of colours/scales/unified line calls that may be different and can be rerun
*zoom out all by default to scale the two laser board sizes in down the left hand side
*use colours or picking to specify the engraving curves
*estimates of time to cut, which can be used to check if order of cut improving.  do cuts after each etch so abort still have working results
*begin relay packing within area and clearance bits in callouts
*export that ply sheet and remove everything on it
*allow this file to serve from BB, which should be on the net somewhere accessible to the Laser Machine
*colour bits by stock material (colour, thickness, type)
*twisted banks and serves out components for the cutter, previews what's being calculated elsewhere.  
</p>


</body>
</html>
